# Copyright (c) 2021 Centre National d'Etudes Spatiales (CNES).
# This file is part of Bulldozer
#
# All rights reserved.

import unittest
import os.path
import rasterio
import numpy as np
from os import remove
from numpy.testing import assert_array_equal
from rasterio.crs import CRS
from bulldozer.core.dsm_preprocess import build_nodata_mask, write_quality_mask

class TestDsmPreprocess(unittest.TestCase):
    
    def test_build_nodata_mask(self):
        # In this case the nodata value is set to -2
        input = np.array([[1,-2,3,4],[-2,1,-2,4],[-2,-2,3,-2],[-2,-2,-2,4]])
        # Expected inner nodata mask
        expected_inner = np.array([[False,False,False,False],[False,False,True,False],
                                    [False,False,False,False],[False,False,False,False]])
        # Expected border nodata mask
        expected_border = np.array([[False,True,False,False],[True,False,False,False],
                                    [True,True,False,True],[True,True,True,False]])
        # output[0] contains border nodata mask and output[1] contains inner nodata mask
        output = build_nodata_mask(input, -2)

        assert_array_equal(output[0], expected_border)
        assert_array_equal(output[1], expected_inner)

        # Same input dsm as previous but we replace the no data value to nan
        input = np.array([[1,np.nan,3,4],[np.nan,1,np.nan,4],
                        [np.nan,np.nan,3,np.nan],[np.nan,np.nan,np.nan,4]])
    
        output = build_nodata_mask(input, np.nan)

        # It should return the same results as previous
        assert_array_equal(output[0], expected_border)
        assert_array_equal(output[1], expected_inner) 
    
    def test_write_quality_mask(self):
        output_dir = os.path.join(os.path.dirname(__file__), 'data/')
        # Input data for the test (manages all possible combinations)
        border_nodata_mask = np.array([[False,False,False,False],[True,True,True,True]])
        inner_nodata_mask = np.array([[False,False,True,True],[False,False,True,True]])
        disturbed_area_mask = np.array([[False,True,False,True],[False,True,False,True]])
        # Metada (rasterio.profile) used in the writting instruction
        meta = {
            'driver': 'GTiff',
            'dtype': float,
            'nodata': None,
            'width': border_nodata_mask.shape[1], 
            'height': border_nodata_mask.shape[0],
            'count': 3,
            'crs': None,
            'transform': rasterio.Affine(0.5, 0.0, 567182.5625, 0.0, -0.5, 6287950.0),
            'tiled': False,
            'interleave': 'pixel'
        }
        # Temporary file used for the test
        quality_mask_path = output_dir + "quality_mask.tif"


        # Tested function call
        write_quality_mask(border_nodata_mask, inner_nodata_mask, disturbed_area_mask, output_dir, meta)
        
        # Reads the mask generated by the function
        with rasterio.open(quality_mask_path) as mask_dataset:
            quality_mask = mask_dataset.read(1)

            # Comparaison with the expected values
            expected_quality_mask = np.array([[0,3,2,2],[1,1,1,1]], np.uint8)
            assert_array_equal(quality_mask, expected_quality_mask)

            # The function should overwrites some metadata values
            self.assertEqual(mask_dataset.profile['count'], 1)
            self.assertEqual(mask_dataset.profile['nodata'], 0)
            self.assertEqual(mask_dataset.profile['dtype'], 'uint8')


        # Removes the quality mask generated during the test
        remove(quality_mask_path)
